//
//  Globe.swift
//  SwiftDune
//
//  Created by Christophe Buguet on 01/05/2024.
//

import Foundation

// Based on original Rust code by Thomas Fach-Pedersen
// @see https://github.com/madmoose/dune-rust/blob/main/globe_renderer/src/globe_renderer.rs


let GLOBE_MAP_PALETTE: [UInt8] = [
    0x00, 0x00, 0x00, 0x00, 0x00, 0xaa, 0x00, 0xaa, 0x00, 0x00, 0xaa, 0xaa,
    0xaa, 0x00, 0x00, 0xff, 0xd2, 0x51, 0xaa, 0x55, 0x00, 0xaa, 0xaa, 0xaa,
    0x55, 0x55, 0x55, 0x55, 0x55, 0xff, 0x55, 0xff, 0x55, 0x55, 0xff, 0xff,
    0xff, 0x55, 0x55, 0xff, 0x55, 0xff, 0xff, 0xff, 0x55, 0xff, 0xff, 0xff,
    0x04, 0x18, 0x35, 0x65, 0x65, 0x6d, 0xa6, 0x8e, 0x55, 0xce, 0xa2, 0x69,
    0xfb, 0xe7, 0x6d, 0xff, 0xff, 0x9a, 0xff, 0xf7, 0x55, 0xff, 0xdb, 0x6d,
    0xff, 0xb6, 0x00, 0xdb, 0x92, 0x28, 0xdb, 0x49, 0x28, 0xb6, 0x00, 0x00,
    0x92, 0x49, 0x00, 0x6d, 0x49, 0x3d, 0x6d, 0x28, 0x28, 0x00, 0x00, 0x00,
    0x8a, 0xdf, 0x5d, 0xb6, 0xff, 0x6d, 0x00, 0xb2, 0x00, 0x00, 0xce, 0x41,
    0xdf, 0x0c, 0x00, 0xf3, 0x35, 0x08, 0xe7, 0x08, 0x00, 0xdb, 0x0c, 0x00,
    0xb6, 0x0c, 0x00, 0x9e, 0x08, 0x00, 0x71, 0x04, 0x00, 0x35, 0x00, 0x00,
    0x55, 0x00, 0x00, 0x51, 0x00, 0x00, 0x3d, 0x00, 0x00, 0x1c, 0x00, 0x00,
    0x45, 0x45, 0x4d, 0x65, 0x65, 0x6d, 0xa6, 0x8e, 0x55, 0xce, 0xa2, 0x69,
    0x00, 0x35, 0x82, 0x00, 0x45, 0x8e, 0x00, 0x28, 0x75, 0x00, 0x1c, 0x69,
    0x00, 0x18, 0x61, 0x00, 0x10, 0x59, 0x00, 0x0c, 0x51, 0x00, 0x04, 0x49,
    0x00, 0x04, 0x41, 0x00, 0x00, 0x39, 0x00, 0x00, 0x35, 0x00, 0x55, 0x9e,
    0x00, 0x00, 0x2d, 0x00, 0x04, 0x41, 0x04, 0x10, 0x55, 0x0c, 0x20, 0x69,
    0x14, 0x35, 0x7d, 0x20, 0x49, 0x92, 0x2d, 0x61, 0xa2, 0x35, 0x71, 0xa6,
    0x41, 0x82, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xe3, 0x31, 0x0c, 0xc6, 0x28, 0x08, 0xb2, 0x18, 0x08,
    0x82, 0x18, 0x04, 0x61, 0x00, 0x00, 0xaa, 0x45, 0x00, 0xc2, 0x69, 0x00,
    0xdf, 0x9a, 0x00, 0xfb, 0xd2, 0x00, 0xfb, 0xeb, 0x28, 0xff, 0xff, 0x59,
    0xff, 0xff, 0x82, 0xff, 0xff, 0xaa, 0xff, 0xff, 0xd2, 0xff, 0xff, 0xff,
    0x10, 0x10, 0x10, 0x1c, 0x20, 0x20, 0x24, 0x35, 0x35, 0x28, 0x49, 0x49,
    0x24, 0x5d, 0x5d, 0x1c, 0x71, 0x6d, 0x0c, 0x86, 0x82, 0x18, 0x8a, 0x92,
    0x28, 0x8a, 0x9e, 0x39, 0x8a, 0xaa, 0x4d, 0x8e, 0xb6, 0x6d, 0xa2, 0xc2,
    0x92, 0xb6, 0xce, 0xba, 0xce, 0xdb, 0xeb, 0xeb, 0xeb, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x14, 0x24, 0x41, 0x20, 0x35, 0x49, 0x28, 0x41, 0x55, 0x35, 0x4d, 0x61,
    0x3d, 0x59, 0x71, 0x49, 0x65, 0x7d, 0x55, 0x75, 0x8e, 0x65, 0x82, 0x9a,
    0x71, 0x92, 0xa6, 0x82, 0xa2, 0xb2, 0x92, 0xae, 0xc2, 0xa2, 0xbe, 0xd2,
    0xb6, 0xce, 0xdf, 0xc6, 0xdf, 0xef, 0xdf, 0xf3, 0xff, 0x00, 0x00, 0x00
]

let MAX_TILT: Int = 99

struct RotationEntry {
    var mapRowStart: Int16
    var mapRowLen: UInt16
    var fp: UInt32
}

enum GlobeSection {
    case farNorth
    case nearNorth
    case nearSouth
    case farSouth
}

struct GlobeSectionLatitude {
    var section: GlobeSection = .farNorth
    var latitude: UInt8 = 0
}

enum GlobeHalf {
    case upper
    case lower
}


enum GlobeMove {
    case up
    case down
    case left
    case right
}


final class Globe {
    private let engine = DuneEngine.shared
    private var tablat: [UInt8]
    
    private var rotationLookupTable: [RotationEntry] = []
    private var tiltLookupTable: [GlobeSectionLatitude] = []
    private var globData: [UInt8]
    private var map: [UInt8]
    
    private var tilt: Int16 = 0
    private var rotation: UInt16 = 0
    private var initialRotation: UInt16 = 0

    init() {
        let tablatResource = Resource("TABLAT.BIN", uncompressed: true)
        let globDataResource = Resource("GLOBDATA.HSQ")
        let mapResource = Resource("MAP.HSQ")

        self.tablat = tablatResource.unpackedData
        self.globData = globDataResource.unpackedData
        self.map = mapResource.unpackedData
        
        initTiltLookupTable()
        initRotationLookupTable()
        initPalette()
    }
    
    
    private func initTiltLookupTable() {
        tiltLookupTable.reserveCapacity(4 * MAX_TILT - 4)

        for i: UInt8 in 1...98 {
            tiltLookupTable.append(GlobeSectionLatitude(section: .farSouth, latitude: i))
        }
        
        for i: UInt8 in (0...98).reversed() {
            tiltLookupTable.append(GlobeSectionLatitude(section: .nearSouth, latitude: i))
        }
        
        for i: UInt8 in 1...98 {
            tiltLookupTable.append(GlobeSectionLatitude(section: .nearNorth, latitude: i))
        }

        for i: UInt8 in (2...98).reversed() {
            tiltLookupTable.append(GlobeSectionLatitude(section: .farNorth, latitude: i))
        }
    }
    
    
    private func initRotationLookupTable() {
        rotationLookupTable.reserveCapacity(MAX_TILT)
        
        for i in 0..<MAX_TILT {
            let offset = 8 * i
            let mapRowStart = Int16.fromBytes(tablat, offset)
            let mapRowLen = UInt16.fromBytes(tablat, offset + 2)
            rotationLookupTable.append(RotationEntry(mapRowStart: mapRowStart, mapRowLen: mapRowLen, fp: 0))
        }
        
        precalculateGlobeRotationLookupTable(0)
    }
    
    
    private func initPalette() {
        var i = 0
        
        while i < 256 {
            let index = (i * 3)
            let color = 0xFF000000 | (UInt32(GLOBE_MAP_PALETTE[index + 2]) << 16) | (UInt32(GLOBE_MAP_PALETTE[index + 1]) << 8) | UInt32(GLOBE_MAP_PALETTE[index])
            engine.palette.rawPointer[i] = color
            i += 1
        }
    }
    
    
    private func globDataTable2(_ x: Int, _ latitude: Int) -> UInt8 {
        let index = 3290 + x * 200 + latitude
        return globData[index]
    }
    
    
    private func globDataTable3(_ x: Int, _ latitude: Int) -> Int16 {
        let index = 3290 + x * 200 + latitude + 100
        return Int16(Int8(truncatingIfNeeded: globData[index]))
    }
    
    
    private func precalculateGlobeRotationLookupTable(_ rotation: UInt16) {
        var dxax: UInt32 = 398 * UInt32(rotation)
        dxax = (dxax & ~0xFFFF)

        self.rotationLookupTable[0].fp = dxax
        dxax += 0x8000

        let bx = UInt32(dxax / 398)
        var i = 1
        
        while i < rotationLookupTable.count {
            let dxax: UInt32 = 2 * bx * UInt32(self.rotationLookupTable[i].mapRowLen)
            self.rotationLookupTable[i].fp = dxax
            i += 1
        }
    }
    
    
    private func mapColor(_ offset: Int16) -> UInt8 {
        let mapIndex = 0x62FC + Int(offset)
        let mapValue = self.map[mapIndex]
        let flags = (mapValue >> 4) & 3
        var color = mapValue & 0x0f

        if flags == 0x10 && color < 8 {
           color += 12
        }

        return color + 0x10
    }
    
    
    private func drawHalf(_ buffer: PixelBuffer, half: GlobeHalf, tilt: Int16) {
        let centerX = 160 - 1
        let centerY = 80 - 1
        var y: Int = 0
        
        var i = 0
        
        func readGlobDataNext() -> Int8 {
            let val = Int8(truncatingIfNeeded: globData[i])
            i += 1
            return val
        }
        
        while i < globData.count {
            var n = readGlobDataNext()
            let lineLen = UInt32(truncatingIfNeeded: ~n)
            
            if lineLen == 0 {
                break
            }
            
            var x = 0
            
            while x < lineLen {
                switch half {
                case .upper: n = readGlobDataNext()
                case .lower: n = -readGlobDataNext()
                }
                
                let index = Int(n) + 196 + Int(tilt)
                let sectionLatitude = self.tiltLookupTable[index]
                let bx2 = globDataTable2(x, Int(sectionLatitude.latitude))
                var ax = globDataTable3(x, Int(sectionLatitude.latitude))
                
                let bp = Int(bx2 / 2)
                var bx = self.rotationLookupTable[bp].mapRowStart
                var cx = Int16(self.rotationLookupTable[bp].mapRowLen)
                var dx = Int16(self.rotationLookupTable[bp].fp >> 16)
                
                switch sectionLatitude.section {
                case .farNorth:
                    ax = cx - ax
                    bx = -bx
                    break
                case .nearNorth:
                    bx = -bx
                    break
                case .nearSouth:
                    break
                case .farSouth:
                    ax = cx - ax
                }

                cx *= 2
                var colorMapIndex1 = dx - ax
                
                if colorMapIndex1 < 0 {
                    colorMapIndex1 += cx
                }
                
                colorMapIndex1 += bx
                dx += ax
                
                let py = switch half {
                case .upper: centerY - y
                case .lower: centerY + y
                }
                
                let colorIndex1 = self.mapColor(colorMapIndex1)
                let bufferIndex1 = Int(centerX - x) + (py * buffer.width)
                buffer.rawPointer[bufferIndex1] = colorIndex1
 
                var colorMapIndex2 = dx - cx
                
                if colorMapIndex2 < 0 {
                    colorMapIndex2 += cx
                }
                
                colorMapIndex2 += bx
                
                let colorIndex2 = self.mapColor(colorMapIndex2)
                let bufferIndex2 = Int(centerX + x + 1) + (py * buffer.width)
                buffer.rawPointer[bufferIndex2] = colorIndex2
                
                x += 1
            }

            y += 1
        }
    }
    
    
    func setOrientation(tilt: Int16, rotation: UInt16) {
        self.tilt = Math.clamp(tilt, -96, 96)
        self.initialRotation = rotation
        self.rotation = rotation
        precalculateGlobeRotationLookupTable(rotation)
    }
    
    
    func move(_ move: GlobeMove) {
        switch move {
        case .left:
            if self.rotation > UInt16.min {
                self.rotation -= 100
            } else {
                self.rotation = 65500
            }
            break
        case .right:
            if self.rotation < 65500 {
                self.rotation += 100
            } else {
                self.rotation = 0
            }
            break
        case .up:
            self.tilt -= 1
            break
        case .down:
            self.tilt += 1
            break
        }

        setOrientation(tilt: self.tilt, rotation: self.rotation)
    }
    
    
    func update(_ time: TimeInterval) {
        let rotation = initialRotation + UInt16(Int(ceil(time) * 200.0) % 65000)
        self.rotation = rotation

        self.precalculateGlobeRotationLookupTable(rotation)
    }
    
    
    public func render(buffer: PixelBuffer) {
        self.precalculateGlobeRotationLookupTable(rotation)
        
        self.drawHalf(buffer, half: .upper, tilt: tilt)
        self.drawHalf(buffer, half: .lower, tilt: tilt)
    }
}
